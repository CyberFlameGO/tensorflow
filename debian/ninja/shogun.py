#!/usr/bin/python3.6
# Copyright (C) 2018 Mo Zhou. MIT/Expat License.

from typing import *
import sys
import re
import os
import argparse
from ninja_syntax import Writer


def filteroutExternal(sourcelist: List[str]) -> List[str]:
    '''
    Filter out external dependencies from bazel dependency dump
    '''
    external = set()
    ret = []
    for src in sourcelist:
        x = re.match('^@(\w*).*', src)
        if x is None:
            ret.append(src)
        else:
            external.update(x.groups())
    print('The specified source list requires external deps:', external)
    return ret


def mangleBazel(sourcelist: List[str]) -> List[str]:
    '''
    mangling source file path
    '''
    ret = []
    for x in sourcelist:
        x = re.sub('^//', '', x)
        x = re.sub(':', '/', x)
        ret.append(x)
    return ret


def eGrep(pat: str, sourcelist: List[str]) -> (List[str], List[str]):
    '''
    Just like grep -E
    '''
    match, unmatch = [], []
    for item in sourcelist:
        if re.match(pat, item):
            match.append(item)
        else:
            unmatch.append(item)
    return match, unmatch


def ninjaProto(cur, protolist: List[str]) -> None:
    '''
    write ninja rules for the protofiles. cur is ninja writer
    '''
    for proto in protolist:
        output = [re.sub('.proto$', '.pb.cc', proto),
                re.sub('.proto$', '.pb.h', proto)]
        cur.build(output, 'PROTOC', inputs=proto)


def ninjaProtoText(cur, protolist: List[str]) -> None:
    '''
    write ninja rules for to proto_text files. cur is ninja writer
    '''
    for proto in protolist:
        output = [re.sub('.proto$', '.pb_text.cc', proto),
                re.sub('.proto$', '.pb_text.h', proto),
                re.sub('.proto$', '.pb_text-impl.h', proto)]
        cur.build(output, 'PROTO_TEXT', inputs=proto)


def ninjaCXXOBJ(cur, cclist: List[str]) -> List[str]:
    '''
    write ninja rules for building .cc files into object files
    '''
    objs = []
    for cc in cclist:
        output = re.sub('.cc$', '.o', cc)
        objs.append(cur.build(output, 'CXX_OBJ', inputs=cc)[0])
    return objs


def shogunProtoText(argv):
    '''
    Build proto_text
    '''
    ag = argparse.ArgumentParser()
    ag.add_argument('-i', help='list of source files', type=str, required=True)
    ag.add_argument('-o', help='where to write the ninja file', type=str, default='proto_text.ninja')
    ag.add_argument('-B', help='build directory', type=str, default='.')
    ag = ag.parse_args(argv)

    sourcelist = [l.strip() for l in open(ag.i, 'r').readlines()]
    sourcelist = filteroutExternal(sourcelist)
    sourcelist = mangleBazel(sourcelist)

    # Instantiate ninja writer
    cursor = Writer(open(ag.o, 'w'))
    cursor.comment(f'automatically generated by {__file__}')
    cursor.variable('CXXFLAGS', '-O2 -fPIC -I. -lpthread -lprotobuf')

    # generate .pb.cc and .pb.h
    protolist, sourcelist = eGrep('.*.proto$', sourcelist)
    cursor.rule('PROTOC', f'protoc $in --cpp_out {ag.B}')
    ninjaProto(cursor, protolist)

    # ignore .h files and third_party, and windows source
    _, sourcelist = eGrep('.*.h$', sourcelist)
    _, sourcelist = eGrep('^third_party', sourcelist)
    _, sourcelist = eGrep('.*windows/env_time.cc$', sourcelist)

    # compile .cc source
    cclist, sourcelist = eGrep('.*.cc', sourcelist)
    cursor.rule('CXX_OBJ', f'g++ $CXXFLAGS -c $in -o $out')
    proto_text_objs = ninjaCXXOBJ(cursor, cclist)

    # link the final executable
    cursor.rule('CXX_EXEC', f'g++ $CXXFLAGS $in -o $out')
    cursor.build('proto_text', 'CXX_EXEC', inputs=proto_text_objs)

    # fflush
    cursor.close()

    print('Unprocessed files:', sourcelist)


def shogunTFFrame(argv):
    '''
    Build libtensorflow_framework.so
    '''
    ag = argparse.ArgumentParser()
    ag.add_argument('-i', help='list of source files', type=str, required=True)
    ag.add_argument('-g', help='list of generated files', type=str, required=True)
    ag.add_argument('-o', help='where to write the ninja file', type=str, default='libtensorflow_framework.ninja')
    ag.add_argument('-B', help='build directory', type=str, default='.')
    ag = ag.parse_args(argv)

    srclist = filteroutExternal([l.strip() for l in open(ag.i, 'r').readlines()])
    genlist = filteroutExternal([l.strip() for l in open(ag.g, 'r').readlines()])
    srclist, genlist = mangleBazel(srclist), mangleBazel(genlist)

    # Instantiate ninja writer
    cursor = Writer(open(ag.o, 'w'))
    cursor.comment(f'automatically generated by {__file__}')
    cursor.variable('CXXFLAGS', '-O2 -fPIC -I. -lpthread -lprotobuf')
    cursor.variable('PROTO_TEXT_ELF', f'{ag.B}/proto_text')

    # generate .pb.cc and .pb.h
    _, srclist = eGrep('.*.proto$', srclist)
    protolist, genlist = eGrep('.*.pb.cc', genlist)
    _, genlist = eGrep('.*.pb.h', genlist)
    protolist = [re.sub('.pb.cc', '.proto', x) for x in protolist]
    cursor.rule('PROTOC', f'protoc $in --cpp_out {ag.B}')
    ninjaProto(cursor, protolist)

    # generate .pb_text.cc .pb_text.h .pb_test-impl.h
    _, srclist = eGrep('.*.proto$', srclist)
    protolist, genlist = eGrep('.*.pb_text.cc', genlist)
    _, genlist = eGrep('.*.pb_text.h', genlist)
    _, genlist = eGrep('.*.pb_text-impl.h', genlist)
    protolist = [re.sub('.pb_text.cc$', '.proto', x) for x in protolist]
    cursor.rule('PROTO_TEXT', f'$PROTO_TEXT_ELF {ag.B}/tensorflow/core tensorflow/core tensorflow/tools/proto_text/placeholder.txt $in')
    ninjaProtoText(cursor, protolist)

    ## ignore .h files and third_party, and windows source
    #_, sourcelist = eGrep('.*.h$', sourcelist)
    #_, sourcelist = eGrep('^third_party', sourcelist)
    #_, sourcelist = eGrep('.*windows/env_time.cc$', sourcelist)

    ## compile .cc source
    #cclist, sourcelist = eGrep('.*.cc', sourcelist)
    #cursor.rule('CXX_OBJ', f'g++ $CXXFLAGS -c $in -o $out')
    #proto_text_objs = ninjaCXXOBJ(cursor, cclist)

    ## link the final executable
    #cursor.rule('CXX_EXEC', f'g++ $CXXFLAGS $in -o $out')
    #cursor.build('proto_text', 'CXX_EXEC', inputs=proto_text_objs)

    ## fflush
    #cursor.close()

    print('Unprocessed source files:', srclist)
    print('Unprocessed generated files:', genlist)


if __name__ == '__main__':

    try:
        sys.argv[1]
    except IndexError as e:
        print(e, 'you must specify a subcommand')
        exit(1)

    if sys.argv[1] == 'proto_text':
        shogunProtoText(sys.argv[2:])
    elif sys.argv[1] == 'tf_framework':
        shogunTFFrame(sys.argv[2:])
    else:
        raise NotImplementedError(sys.argv[1:])
