#!/usr/bin/python3.6
# Copyright (C) 2018 Mo Zhou. MIT/Expat License.

from typing import *
import sys
import re
import os
import argparse
from ninja_syntax import Writer


def filteroutExternal(sourcelist: List[str]) -> List[str]:
    '''
    Filter out external dependencies from bazel dependency dump
    '''
    external = set()
    ret = []
    for src in sourcelist:
        x = re.match('^@(\w*).*', src)
        if x is None:
            ret.append(src)
        else:
            external.update(x.groups())
    print('The specified source list requires external deps:', external)
    return ret


def mangleBazel(sourcelist: List[str]) -> List[str]:
    '''
    mangling source file path
    '''
    ret = []
    for x in sourcelist:
        x = re.sub('^//', '', x)
        x = re.sub(':', '/', x)
        ret.append(x)
    return ret


def eGrep(pat: str, sourcelist: List[str]) -> (List[str], List[str]):
    '''
    Just like grep -E
    '''
    match, unmatch = [], []
    for item in sourcelist:
        if re.match(pat, item):
            match.append(item)
        else:
            unmatch.append(item)
    return match, unmatch


def ninjaProto(cur, protolist: List[str]) -> None:
    '''
    write ninja rules for the protofiles. cur is ninja writer
    '''
    for proto in protolist:
        output = [re.sub('.proto$', '.pb.cc', proto),
                re.sub('.proto$', '.pb.h', proto)]
        cur.build(output, 'PROTOC', inputs=proto)


def ninjaCXXOBJ(cur, cclist: List[str]) -> List[str]:
    '''
    write ninja rules for building .cc files into object files
    '''
    objs = []
    for cc in cclist:
        output = re.sub('.cc$', '.o', cc)
        objs.append(cur.build(output, 'CXX_OBJ', inputs=cc)[0])
    return objs


if __name__ == '__main__':
    ag = argparse.ArgumentParser()
    ag.add_argument('-i', help='list of source files', type=str, required=True)
    ag.add_argument('-o', help='where to write the ninja file', type=str, required=True)
    ag.add_argument('-B', help='build directory', type=str, default='.')
    ag = ag.parse_args()

    sourcelist = [l.strip() for l in open(ag.i, 'r').readlines()]
    sourcelist = filteroutExternal(sourcelist)
    sourcelist = mangleBazel(sourcelist)

    # Instantiate ninja writer
    cursor = Writer(open(ag.o, 'w'))
    cursor.comment(f'automatically generated by {__file__}')
    cursor.variable('CXXFLAGS', '-O2 -fPIC -I. -lpthread -lprotobuf')

    # generate .pb.cc and .pb.h
    protolist, sourcelist = eGrep('.*.proto$', sourcelist)
    cursor.rule('PROTOC', f'protoc $in --cpp_out {ag.B}')
    ninjaProto(cursor, protolist)

    # ignore .h files and third_party, and windows source
    _, sourcelist = eGrep('.*.h$', sourcelist)
    _, sourcelist = eGrep('^third_party', sourcelist)
    _, sourcelist = eGrep('.*windows/env_time.cc$', sourcelist)

    # compile .cc source
    cclist, sourcelist = eGrep('.*.cc', sourcelist)
    cursor.rule('CXX_OBJ', f'g++ $CXXFLAGS -c $in -o $out')
    proto_text_objs = ninjaCXXOBJ(cursor, cclist)

    # link the final executable
    cursor.rule('CXX_EXEC', f'g++ $CXXFLAGS $in -o $out')
    cursor.build('proto_text', 'CXX_EXEC', inputs=proto_text_objs)

    # fflush
    cursor.close()

    print('Unprocessed files:', sourcelist)

